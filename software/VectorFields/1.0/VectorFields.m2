-- -*- coding: utf-8 -*-
newPackage(
	"VectorFields",
    	Version => "1.0", 
    	Date => "April 9, 2013",
    	Authors => {{Name => "Brian Pike", 
		  Email => "bpike@utsc.utoronto.ca", 
		  HomePage => "http://www.utsc.utoronto.ca/~bpike/"}},
    	Headline => "VectorFields",
    	DebuggingMode => true
    	)

export {
isModuleOfVectorFields,
isHomogeneousModuleOfVectorFields,
bracket,der,derlogV,derlogH,applyVF,
isLieAlgebra,
computeCommutator,
computeDerivedSeries,
computeModuleBracket, 
computeLowerCentralSeries,
isFreeDivisor,
stratifyByRank,
getDim,
isHolonomic,
isHHolonomic
}

needsPackage "SimpleDoc"

mydoc:="";

mydoc=concatenate(mydoc,///
Node
	Key
		VectorFields
	Headline
		a package for handling modules of vector fields
	Description
		Text
			VectorFields provides elementary functions (Lie bracket, etc.)
			to study modules of vector fields on affine space.
			This package may be of interest to those studying 
			representations of Lie groups, foliations, or logarithmic
			vector fields.
		Text
			We represent a vector field on affine $n$-space as an element $V$ of
			$R^n$, where $R$ is a ring of polynomials in $n$ variables.
			The standard basis of $R^n$ is identified with the ordering of variables
			given by $vars(R)$, and hence each coordinate of $V$ is the coefficient of
			a derivative with respect to a particular variable.
			Since it is convenient, we often work with either a submodule of $R^n$ or
			a matrix whose image is a submodule of $R^n$.
		Example
			R=QQ[x,y,z];
		Text
			Find the vector fields which are tangent to $xy-z^2=0$. For instance,
			$2y \partial_y + z \partial_z$ is such a vector field.
		Example
			D=derlogV(ideal (x*y-z^2))
			isSubset(image matrix {{0},{2*y},{z}},image D)
		Text
			The ordering of variables in the ring give the meaning of each row of D.
		Example
			vars(R)
			isModuleOfVectorFields(D)
			isModuleOfVectorFields(image D)
			isLieAlgebra(D)
	Subnodes
		isModuleOfVectorFields
		isLieAlgebra
		derlogV
	SeeAlso
		matrix
///);

-- BASIC TESTS THAT CAN BE PERFORMED ON MODULES OF VECTOR FIELDS
mydoc=concatenate(mydoc,///
Node
	Key
		isModuleOfVectorFields
		(isModuleOfVectorFields,Module)
		(isModuleOfVectorFields,Matrix)
	Headline
		test whether a module can be interpreted as a module of vector fields
	Usage
		b=isModuleOfVectorFields(m)
		b=isModuleOfVectorFields(M)
	Inputs
		m:Module
		M:Matrix
			whose image is the module of interest
	Outputs
		b:Boolean
	Description
		Text
			For a module to be interpreted as a module of vector fields, the
			module must be presented as a submodule of a free module whose rank
			equals the number of variables in the ring.
		Example
			R=QQ[x,y];
			isModuleOfVectorFields(image matrix {{x,y^2}})
			isModuleOfVectorFields(image matrix {{x,y^2},{0,0}})
	SeeAlso
		VectorFields
///);
-- The module m must be a submodule of a free module whose
-- rank equals the number of variables in the ring.
isModuleOfVectorFields = method(TypicalValue=>Boolean);
isModuleOfVectorFields(Module) := (m) -> (
	return (relations(m)==0 and rank(ambient(m))==numgens(ring(m))); 
);

isModuleOfVectorFields(Matrix) := (m) -> (
	return (numRows(m)==numgens(ring(m)));
);

mydoc=concatenate(mydoc,///
Node
	Key
		isHomogeneousModuleOfVectorFields
		(isHomogeneousModuleOfVectorFields,Module,Set)
		(isHomogeneousModuleOfVectorFields,Matrix,Set)
		(isHomogeneousModuleOfVectorFields,Module,List)
		(isHomogeneousModuleOfVectorFields,Matrix,List)
		(isHomogeneousModuleOfVectorFields,Module)
		(isHomogeneousModuleOfVectorFields,Matrix)
	Headline
		determine whether a module is generated by homogeneous vector fields.
	Usage
		b=isHomogeneousModuleOfVectorFields(m,s)
		b=isHomogeneousModuleOfVectorFields(M,s)
		b=isHomogeneousModuleOfVectorFields(m)
		b=isHomogeneousModuleOfVectorFields(M)
	Inputs
		m:Module
		M:Matrix
			whose image is the module of interest
		s:Set
		s:List
			a set or list of integers greater than or equal to -1
	Outputs
		b:Boolean
	Description
		Text
			Determine whether the module is generated by homogeneous vector fields,
			or homogeneous vector fields of degrees appearing in the set.
			For the purposes of this command, a zero vector field is homogeneous
			of degree -1, a vector field with constant coefficients is homogeneous
			of degree 0, and otherwise a vector field is homogeneous of degree d
			if all coefficients are of degree d in the ring of the module.
			Note that if the ring has multidegrees, then only the first number will
			be used.
		Example
			R=QQ[x,y];
		Text
			This is not homogeneous because of $1 \partial_x + 2x \partial_y$: 
		Example
			M1=derlogV(ideal (x^2-y))
			isHomogeneousModuleOfVectorFields(image M1)
		Text
			This is homogeneous, of degree 0 and 1:
		Example
			M2=derlogV(ideal (x^2))
			isHomogeneousModuleOfVectorFields(M2)
			isHomogeneousModuleOfVectorFields(M2,{0,1})
		Text
			This is homogeneous, of degrees -1, 1, and 2:
		Example
			M3=matrix {{x,0,0},{0,y^2,0}}
			isHomogeneousModuleOfVectorFields(M3)
			isHomogeneousModuleOfVectorFields(M3,{0,1,2})
			isHomogeneousModuleOfVectorFields(M3,{-1,1,2})
	SeeAlso
		VectorFields
///);

-- Check if the coefficients of vf are all homogeneous.
-- Return -2 if it is NOT homogeneous.
-- Return -1 if the coefficients are all zero.
-- Otherwise, return the degree.  In particular, return  0 if the coefficients are constants.
getHomogeneousVFDegree := (vf) -> (
	-- vf should be a n\times 1 matrix.
	assert(numColumns(vf)==1);
	if (vf==0) then return -1;
	-- Are they all homogeneous?
	x:=apply(flatten entries vf,isHomogeneous);
	if not(all(x,a->a)) then return -2;
	-- So now all coeffs are homogeneous.  What degree?
	-- If we have multidegrees, then we'll just take the first one.
	x=apply(flatten entries vf,a->first degree a);
	-- Note that degree(0_R)==-infinity and first(degree(0_R))==-1...? 
	-- However, we've taken care of vf==0 above, so m>=0
	m:=max(x);
	if all(x,a->(a==m or a==first(degree(0_(ring(vf)))) ) ) then
		return m;
	return -2;
);

-- Check if the vectorfields are all homogeneous...
isHomogeneousModuleOfVectorFields = method(TypicalValue=>Boolean);
isHomogeneousModuleOfVectorFields(Matrix,Set) := (m,s) -> (
	if not(isModuleOfVectorFields(m)) then (
		return false;
	);
	return all(numColumns(m),i-> member(getHomogeneousVFDegree(m_{i}),s));
);

isHomogeneousModuleOfVectorFields(Matrix) := (m) -> (
	if not(isModuleOfVectorFields(m)) then (
		return false;
	);
	return all(numColumns(m),i-> not(getHomogeneousVFDegree(m_{i})==-2));
);

isHomogeneousModuleOfVectorFields(Module,Set) := (M,s) -> (
	if not(isModuleOfVectorFields(M)) then (
		return false;
	);
	return isHomogeneousModuleOfVectorFields(gens M,s);
);

isHomogeneousModuleOfVectorFields(Module) := (M) -> (
	if not(isModuleOfVectorFields(M)) then (
		return false;
	);
	return isHomogeneousModuleOfVectorFields(gens M);
);

isHomogeneousModuleOfVectorFields(Matrix,List) := (M,s) -> (
	return isHomogeneousModuleOfVectorFields(M,set(s));
);

isHomogeneousModuleOfVectorFields(Module,List) := (M,s) -> (
	return isHomogeneousModuleOfVectorFields(M,set(s));
);

-- OPERATIONS ON MODULES OF VECTOR FIELDS
bracketTwo := (vf1,vf2,variables) -> (
	-- Compute the derivation f->vf1(vf2(f))-vf2(vf1(f)).
	assert(numColumns(vf1)==1 and numColumns(vf2)==1);
	ans:=mutableMatrix (0*vf1);
	i:=0;
	j:=0;
	for i from 0 when i<numRows(variables) do
	(
		for j from 0 when j<numRows(variables) do
		(
			ans_(i,0)=ans_(i,0)+
				(vf1_(j,0)*diff(variables_(j,0),vf2_(i,0)) -
				 vf2_(j,0)*diff(variables_(j,0),vf1_(i,0)));
		);
	);
	return(matrix ans);
);

bracketMany := (M1,M2,variables) -> (
	-- M1 and M2 should be matrices whose columns are vector fields.
	-- Return the bracket of all pairs of vfs from M1 and M2.
	mat := matrix mutableMatrix(ring(M1),numRows(M1),0);
	for i from 0 to numColumns(M1)-1 do (
		for j from 0 to numColumns(M2)-1 do (
			mat=mat|bracketTwo(M1_{i},M2_{j},variables);
		);
	);
	return mat;
);

mydoc=concatenate(mydoc,///
Node
	Key
		bracket
		(bracket,Module,Module)
		(bracket,Matrix,Matrix)
		(bracket,Matrix,Matrix,List)
	Headline
		compute the Lie bracket of vector fields
	Usage
		x=bracket(m1,m2)
		X=bracket(M1,M2)
		X=bracket(M1,M2,L)
	Inputs
		m1:Module
		m2:Module
		M1:Matrix
			whose image is the module of interest
		M2:Matrix
			whose image is the module of interest
		L:List
			of 2-element lists, giving indices of columns of M1 and of M2
	Outputs
		x:Module
		X:Matrix
			where the output type matches the input type
	Description
		Text
			Computes the Lie bracket of all pairs of vector fields from the
			first and second parameters.  If a specific ordering of the outputs
			is desired, then a specific set of generators and a list L of
			column index pairs should be provided.
		Example
			R=QQ[x,y];
			A=matrix {{0},{x}};
			B=matrix {{x^2},{y}};
			C=matrix {{1},{x}};
			bracket(image(A),image(B))
			bracket(A,B)
			bracket(B,A)
			bracket(A,C)
			bracket(A,B|C)
			bracket(A|C,B|C,{{0,0},{1,1}})==bracket(A,B)|bracket(C,C)
		Text
			An action of SL_2 on GL_2 differentiates to the following vector fields:
		Example
			R=QQ[a,b,c,d];
			e=matrix {{c},{d},{0},{0}};
			f=matrix {{0},{0},{a},{b}};
			h=matrix {{-a},{-b},{c},{d}};
		Text
			Verify that this is a representation of sl_2, where [e,f]=h, [h,f]=-2f, [h,e]=2e.
		Example
			bracket(e,f)-h
			bracket(h,f)+2*f
			bracket(h,e)-2*e
	SeeAlso
		VectorFields
///);

-- bracket should return matrices or modules, depending on its inputs.
bracket = method();
bracket(Matrix,Matrix) := (m1,m2) -> (
	assert(isModuleOfVectorFields(m1) and isModuleOfVectorFields(m2) and ring(m1)===ring(m2));
	variables:=transpose vars(ring(m1));
	return bracketMany(m1,m2,variables);
);

bracket(Module,Module) := (m1,m2) -> (
	assert(isModuleOfVectorFields(m1) and isModuleOfVectorFields(m2) and ring(m1)===ring(m2));
	variables:=transpose vars(ring(m1));
	return image bracketMany(gens m1,gens m2,variables);
);

bracket(Matrix,Matrix,List) := (m1,m2,l) -> (
	assert(isModuleOfVectorFields(m1) and isModuleOfVectorFields(m2) and ring(m1)===ring(m2));
	assert(instance(l,List));
	assert(all(l, i-> instance(i,List)));
	assert(all(l, i-> (#i)==2));
	nc1:=numColumns(m1);
	nc2:=numColumns(m2);
	assert(all(l, i-> (0<= i_0 and i_0< nc1 and 0<= i_1 and i_1< nc2)));
	variables:=transpose vars(ring(m1));
	mat:=matrix mutableMatrix(ring(m1),numRows(m1),0);
	for combo in l do (
		mat=mat|bracketTwo(m1_{combo_0},m2_{combo_1},variables);
	);
	return mat;
);

-- THINGS THAT RETURN MODULES OF VECTOR FIELDS
mydoc=concatenate(mydoc,///
Node
	Key
		der
		(der,Ideal,Ideal)
	Headline
		compute the vector fields which, as derivations, send one ideal to another
	Usage
		vfs=der(I,J)
	Inputs
		I:Ideal
		J:Ideal
	Outputs
		vfs:Module
	Description
		Text
			Computes the module of vector fields that, as derivations, send all
			elements of I to an element of J.
		Example
			R=QQ[x,y];
			I=ideal (x*y);
			J=ideal (0_R);
			K=ideal (x,y);
			der(J,I)
		Text
			The vector fields tangent to x*y=0:
		Example
			der(I,I)
		Text
			Only multiples of this vector field annihilates x*y
		Example
			der(I,J)
			intersect(der(ideal (x),K),der(ideal (y),K))==der(K,K)
	SeeAlso
		VectorFields
		derlogH
		derlogV
///);

der= method();
-- Returns the module of vector fields which send all elements of I to
-- elements of J.
--   TODO: would doing this for each generator of I and then intersecting be faster?
-- The idea for how to do this was taken from Singular's KVequiv.lib, written by
-- Anne Fruehbis-Krueger, anne@mathematik.uni-kl.de.
der(Ideal,Ideal) := (I,J) -> (
	assert(ring(I)===ring(J));
	I=trim I;
	J=trim J;
	In:=numgens(I);
	Jn:=numgens(J);
	-- The dimension of the space containing our vfs.
	d:=numgens(ring(I));
	-- We will construct a large matrix, and then find the kernel/syzygies of it.
	-- First we need the derivatives of the generators of I.
	--   Shape: In x d
	mat:=transpose(jacobian(I));
	-- The In x In identity matrix in this ring.
	identityMatrix:=matrix(id_( (ring(I))^In ));
	-- Append to the matrix.
	for j from 0 when j<Jn do (
		mat=mat|(identityMatrix * J_j);
	);
	-- Now mat is In x (d+ In*Jn).
	-- TODO: Same as kernel?
	smat:=syz(mat);
	-- Syzygy will be (d+In*Jn)*(??), but we only care about the first d rows.
	return(trim image submatrix(smat,toList(0..(d-1)),));
);

mydoc=concatenate(mydoc,///
Node
	Key
		derlogV
		(derlogV,Ideal)
		(derlogV,RingElement)
		derlogH
		(derlogH,Ideal)
		(derlogH,RingElement)
	Headline
		compute the logarithmic tangent vector fields to an ideal 
	Usage
		v=derlogV(I)
		w=derlogH(J)
		v=derlogV(f)
		w=derlogH(f)
	Inputs
		I:Ideal
		J:Ideal
			J must be principal
		f:RingElement
			the sole generator of the intended ideal
	Outputs
		v:Matrix
		w:Matrix
	Description
		Text
			derlogV computes the 'logarithmic vector fields' to an affine
			variety defined by the ideal I, which are the ambient vector
			fields tangent to the variety.  derlogH computes the the ambient
			vector fields tangent to all level sets of a function defining J. 
			Thus, derlogV(I)=der(I,I) and derlogH(J)=der(J,0).
		Example
			R=QQ[x,y,z];
			f=x*y-z^2;
			derlogV(ideal (f))
			derlogH(ideal (f))
	SeeAlso
		VectorFields
		der
///);

derlogV=method();
derlogV(Ideal) := (I) -> (
	return gens der(I,I);
);

derlogV(RingElement) := (f) -> (
	return derlogV(ideal (f));
);

derlogH=method();
derlogH(Ideal) := (I) -> (
	assert(numgens(I)==1);
	return gens der(I,ideal (0_(ring(I))));
);

derlogH(RingElement) := (f) -> (
	return derlogH(ideal (f));
);

-- APPLY TO A FUNCTION
mydoc=concatenate(mydoc,///
Node
	Key
		applyVF
		(applyVF,Matrix,RingElement)
		(applyVF,Module,RingElement)
	Headline
		apply a vector field to a function
	Usage
		g=applyVF(m,f)
		g=applyVF(M,f)
	Inputs
		m:Module
		M:Matrix
			whose image is the module of interest
		f:RingElement
	Outputs
		g:RingElement
	Description
		Text
			Apply the vector field represented by M to the function f.
			We require that M have one column, or m be generated by a single vector
			field.
		Example
			R=QQ[x,y,z];
			A=matrix {{x},{y},{0}};
			B=matrix {{0},{0},{z}};
			f=x*y-z^2;
			applyVF(A,f)
			applyVF(B,f)
			applyVF(A,x*f)
	SeeAlso
		VectorFields
		derlogH
		derlogV
		der
///);

applyVF=method();
applyVF(Matrix,RingElement) := (m,f) -> (
	assert(isModuleOfVectorFields(m));
	assert(numColumns(m)==1);
	-- This product should be a 1x1 matrix.
	return (  ((transpose jacobian ideal(f)) * m)_(0,0)  );
);
applyVF(Module,RingElement) := (M,f) -> (
	assert(isModuleOfVectorFields(M));
	return applyVF(gens M,f);
);

-- LIE-ALGEBRA RELATED FUNCTIONS
mydoc=concatenate(mydoc,///
Node
	Key
		isLieAlgebra
		(isLieAlgebra,Module)
		(isLieAlgebra,Matrix)
	Headline
		check that a module of vector fields is closed under the Lie bracket
	Usage
		b=isLieAlgebra(m)
		b=isLieAlgebra(M)
	Inputs
		m:Module
		M:Matrix
			whose image is the module of interest
	Outputs
		b:Boolean
	Description
		Text
			Checks whether the module of vector fields m is closed under
			the Lie bracket of vector fields and thus forms a Lie algebra.
		Example
			R=QQ[a,b,c,d];
		Text
			An action of SL_2 on GL_2 differentiates to the following vector fields:
		Example
			e=matrix {{c},{d},{0},{0}};
			f=matrix {{0},{0},{a},{b}};
			h=matrix {{-a},{-b},{c},{d}};
		Text
			Verify that this is sl_2, where [e,f]=h, [h,f]=-2f, [h,e]=2e.
		Example
			bracket(e,f)-h
			bracket(h,f)+2*f
			bracket(h,e)-2*e
		Text
			In particular, the module these generate form a Lie algebra
		Example
			isLieAlgebra(e|f|h)
	SeeAlso
		VectorFields
///);
isLieAlgebra = method(TypicalValue=>Boolean);
isLieAlgebra(Matrix) := (vfs) -> (
	assert(isModuleOfVectorFields(vfs));
	variables:=transpose vars(ring(vfs));
	-- each column of vfs represents a different vector field.
	for combo in subsets(numColumns(vfs),2) do (
		if (not isSubset(image bracketTwo(vfs_{combo_0},vfs_{combo_1},variables), image vfs)) then (
			return false;
		);
	);
	return true;
);

isLieAlgebra(Module) := (M) -> (
	assert(isModuleOfVectorFields(M));
	return isLieAlgebra(gens M);
);

mydoc=concatenate(mydoc,///
Node
	Key
		computeCommutator
		(computeCommutator,Matrix)
		(computeCommutator,Module)
	Headline
		Compute the commutator of a module of vector fields
	Usage
		N=computeCommutator(M)
		n=computeCommutator(m)
	Inputs
		M:Matrix
			a matrix whose image is a module of vector fields
		m:Module
			of vector fields
	Outputs
		N:Matrix
			generators of the commutator module of M.
		n:Module
			the commutator module of M.
	Description
		Text
			Compute the module generated by [X,Y], for X and Y in the module m of vector fields.
			This is a superset of bracket(m,m), as we must
			include all [X,Y] for X,Y generators of m, as well as all
			[fX,gY] for f,g in the ring.  A calculation shows that the commutator
			of m is generated by bracket(m,m) and I*m,
			where I is the ideal generated by all coefficients of a set of
			generators of m.
		Example
			R=QQ[a,b,c,d,e,f];
			fun=a*(d*c-b*e+a*f)*d*b*(b*e-c*d);
			D=image derlogV(ideal (fun))
			trim bracket(D,D)
			trim computeCommutator(D)
	SeeAlso
		VectorFields
		subsets
		bracket
///);

computeCommutator = method();
computeCommutator(Matrix) := (vfs) -> (
	assert(isModuleOfVectorFields(vfs));
	-- Because of the symmetry, it's twice as efficient to do this ourselves,
	-- instead of calling bracket(...)
	mat := matrix mutableMatrix(ring(vfs),numRows(vfs),0);
	variables:=transpose vars(ring(vfs));
	for combo in subsets(numColumns(vfs),2) do ( 
			mat=mat|bracketTwo(vfs_{combo_0},vfs_{combo_1},variables);
	);
	I:=minors(1,vfs);
	return mat|gens(I*image(vfs));
);

computeCommutator(Module) := (m) -> (
	assert(isModuleOfVectorFields(m));
	return trim image computeCommutator(gens m);
);

mydoc=concatenate(mydoc,///
Node
	Key
		computeDerivedSeries
		(computeDerivedSeries,Matrix,ZZ)
		(computeDerivedSeries,Module,ZZ)
	Headline
		Compute the derived series of a module of vector fields
	Usage
		L=computeDerivedSeries(M,k)
		L=computeDerivedSeries(m,k)
	Inputs
		M:Matrix
			a matrix whose image is a module of vector fields
		m:Module
			of vector fields
		k:ZZ
			a nonnegative integer
	Outputs
		L:List
			a list containing m and the first k terms of the derived series of m.
			The return type of the terms of the list agrees with the input type.
	Description
		Text
			Compute the first few terms of the derived series of a module of vector fields.
		Example
			R=QQ[a,b,c];
		Text
			This Lie algebra is isomorphic to gl_2 tensor R
		Example
			D=derlogV(a*c-b^2);
			computeDerivedSeries(D,5)
		Text
			Lie algebra is isomorphic to t_2 tensor R, where t_2 is solvable
		Example
			D=derlogV(a*(a*c-b^2));
			computeDerivedSeries(D,5)
	SeeAlso
		VectorFields
		computeCommutator
		computeDerivedSeries
///);
computeDerivedSeries=method();
computeDerivedSeries(Matrix,ZZ) := (m,k) -> (
	assert(isModuleOfVectorFields(m));
	assert(k>=0);
	lastone:=m;
	l:=for i from 0 when i<k list (
		-- We better simplify this... 
		lastone=gens trim image computeCommutator(lastone)
	);
	return {m}|l;
);

computeDerivedSeries(Module,ZZ) := (M,k) -> (
	assert(isModuleOfVectorFields(M));
	assert(k>=0);
	return apply(computeDerivedSeries(gens M,k),image);
);

mydoc=concatenate(mydoc,///
Node
	Key
		computeModuleBracket
		(computeModuleBracket,Matrix,Matrix)
		(computeModuleBracket,Module,Module)
	Headline
		Compute the bracket of a module of vector fields
	Usage
		D=computeModuleBracket(M,N)
		d=computeModuleBracket(m,n)
	Inputs
		M:Matrix
		N:Matrix
			a matrix whose image is a module of vector fields
		m:Module
		n:Module
			of vector fields
	Outputs
		D:Matrix
		d:Module
			the module bracket of the two modules of vector fields. 
	Description
		Text
			Compute the module generated by [X,Y], for X in m and Y in n. 
			This will be larger than bracket(m,n), as we must use the module
			structure of m and n.
		Example
			R=QQ[a,b,c];
			f=a*b*(a-b)*(a-c*b);
			D=image derlogV(ideal (f))
			trim computeModuleBracket(D,D)
			trim computeModuleBracket(D,image derlogH(f))
	SeeAlso
		VectorFields
		computeCommutator
///);

-- Similarly, we should have a way to compute the bracket of
-- two modules...
-- For X in m1, Y in m2, f in R, we have
--  [fX,Y]= f*[X,Y]-Y(f)*X
--  [X,fY]=-f*[X,Y]+X(f)*Y
--  [fX,gY]=-fg[X,Y]+f X(g) Y-g Y(f) X
computeModuleBracket = method();
computeModuleBracket(Matrix,Matrix) := (m1,m2) -> (
	assert(isModuleOfVectorFields(m1) and isModuleOfVectorFields(m2) and ring(m1)===ring(m2));
	mat:=bracket(m1,m2);
	I1:=minors(1,m1);
	I2:=minors(1,m2);
	return (mat|gens (I1*(image m2))|gens (I2*(image m1)));
);

computeModuleBracket(Module,Module) := (M1,M2) -> (
	assert(isModuleOfVectorFields(M1) and isModuleOfVectorFields(M2) and ring(M1)===ring(M2));
	return image computeModuleBracket(gens M1,gens M2);
);

mydoc=concatenate(mydoc,///
Node
	Key
		computeLowerCentralSeries
		(computeLowerCentralSeries,Matrix,ZZ)
		(computeLowerCentralSeries,Module,ZZ)
	Headline
		Compute the lower central series of a module of vector fields
	Usage
		L=computeLowerCentralSeries(M,k)
		L=computeLowerCentralSeries(m,k)
	Inputs
		M:Matrix
			a matrix whose image is a module of vector fields
		m:Module
			of vector fields
		k:ZZ
			a nonnegative integer
	Outputs
		L:List
			a list containing m and the first k terms of the lower central series of m.
			The return type of the terms of the list agrees with the input type.
	Description
		Text
			Compute the first few terms of the lower central series of a module of vector fields.
		Example
			R=QQ[a,b,c];
		Text
			This Lie algebra is isomorphic to gl_2 tensor R
		Example
			D=derlogV(a*c-b^2);
			computeLowerCentralSeries(D,5)
		Text
			This Lie algebra is isomorphic to t_2 tensor R, where t_2 is solvable
		Example
			D=derlogV(a*(a*c-b^2));
			computeLowerCentralSeries(D,5)
		Text
			This Lie algebra is isomorphic to a nilpotent tensor R.
		Example
			D=matrix {{0},{a},{2*b}};
			computeLowerCentralSeries(D,5)
	SeeAlso
		VectorFields
		computeModuleBracket
		computeDerivedSeries
///);
computeLowerCentralSeries = method();
computeLowerCentralSeries(Matrix,ZZ) := (m,k) -> (
	assert(isModuleOfVectorFields(m));
	assert(k>=0);
	lastone:=m;
	l:=for i from 0 when i<k list (
		-- We better simplify this... 
		lastone=gens trim image computeModuleBracket(lastone,m)
	);
	return {m}|l;
);

computeLowerCentralSeries(Module,ZZ) := (M,k) -> (
	assert(isModuleOfVectorFields(M));
	assert(k>=0);
	return apply(computeLowerCentralSeries(gens M,k),image);
);
-- TODO:
--  - figure out how to compute the
--  -   radical
--  -   center
--  - then use these to test for semisimple, reductive, etc.
--  - pretty-print an element of a Lie algebra of vector fields.
--  - Display a 'multiplication table' for a Lie algebra of vfs.
--  - Make a skew-commutative ring representing the (linear) Lie algebra?

-- FREE DIVISOR-RELATED FUNCTIONS
mydoc=concatenate(mydoc,///
Node
	Key
		isFreeDivisor
		(isFreeDivisor,Matrix)
		(isFreeDivisor,Module)
		(isFreeDivisor,RingElement)
	Headline
		Check to see if the provided information is associated to a free divisor
	Usage
		t=isFreeDivisor(M)
		t=isFreeDivisor(m)
		t=isFreeDivisor(f)
	Inputs
		M:Matrix
			a matrix whose image is a Lie algebra of vector fields
		m:Module
			of vector fields
		f:RingElement
			A polynomial defining a hypersurface
	Outputs
		t:Boolean
			Whether M or m is the module of vector fields for a free divisor, or if f=0
			defines a free divisor
	Description
		Text
			Determine whether the given object is associated to a free divisor, using a variety
			of methods.  When given a RingElement, we compute derlogV(ideal (f)) and test if it is
			a free module by computing a resolution (this method may occasionally give false negatives
			if the resolution computed is not minimal).
			When given a Matrix, we use Saito's criterion: given a set of n vector fields, we check
			that it generates a Lie algebra and that the associated determinant is reduced.
			When given a Module, we find a set of generators and use Saito's criterion. 
		Example
			R=QQ[a,b,c];
		Text
			This is not a free divisor
		Example
			f=a*c-b^2;
			M=derlogV(ideal (f))
			isFreeDivisor(M)
			isFreeDivisor(f)
		Text
			This is a free divisor
		Example
			f=a*(a*c-b^2)
			M=derlogV(ideal (f))
			isFreeDivisor(M)
			isFreeDivisor(image M)
			isFreeDivisor(f)
	SeeAlso
		VectorFields
		bracket
///);
-- These methods use Saito's criterion to decide if their parameter corresponds
-- to a free divisor.
isFreeDivisor = method(TypicalValue => Boolean);
isFreeDivisor(Matrix) := (vfs) -> (
	assert(isModuleOfVectorFields(vfs));
	if not(numColumns(vfs)==numRows(vfs)) then
		return false;
	if not(isLieAlgebra(vfs)) then
		return false;
	f:=det(vfs);
	if f==0 then
		return false;
	-- Is f reduced?
	return (ideal(f)==radical ideal (f));
);
isFreeDivisor(Module) := (m) -> (
	assert(isModuleOfVectorFields(m));
	return isFreeDivisor(gens m);
);
isFreeDivisor(RingElement) := (p) -> (
	-- p is a polynomial.
	R:=res(image derlogV(ideal (p)),LengthLimit=>1);
	if (length(R)==0) then
	(
		return true;
	);
	-- We could be saying that things aren't free divisors when they are, but...
	return false;
);

-- STRATIFICATION-RELATED FUNCTIONS
mydoc=concatenate(mydoc,///
Node
	Key
		stratifyByRank
		(stratifyByRank,Matrix)
		(stratifyByRank,Module)
	Headline
		Compute the closure of the sets where the vector fields have a particular rank
	Usage
		H=stratifyByRank(M)
		H=stratifyByRank(m)
	Inputs
		M:Matrix
			a matrix whose image is a Lie algebra of vector fields
		m:Module
			of vector fields
	Outputs
		H:MutableHashTable
			where the number i maps to the radical ideal defining the set where the vector fields
			have rank less than i.
	Description
		Text
			Compute the closure of the sets where the vector fields have a particular rank.
			If m is a Lie algebra, then this gives some information about the 'orbits' of the
			vector fields.
		Example
			R=QQ[a,b,c];
			f=a*b*(a-b)*(a-c*b);
			D=derlogV(ideal (f))
			S=stratifyByRank(D);
		Text
			D has rank 0 on a=b=0
		Example
			S#1
		Text
			D has rank 3 everywhere off the hypersurface
		Example
			S#3
			Df=derlogH(ideal (f))
			S=stratifyByRank(image Df);
		Text
			This submodule of D has rank <3 everywhere
		Example
			S#3
	SeeAlso
		VectorFields
///);
stratifyByRank = method();
stratifyByRank(Matrix) := (N) -> (
	assert(isModuleOfVectorFields(N));
	-- N is a matrix generating a Lie algebra of vector fields (assumed)?  
	-- returns a hash table where i maps to the radical ideal defining the
	--   set where the vfs have rank less than i.
	mindim:=min({numColumns(N),numRows(N)});
	n:=numRows(N);
	ranklt:=new MutableHashTable;
	-- When it makes sense to take minors, do so.
	for i from 1 when i<=mindim do (
		print(concatenate("  Taking minors of order ",toString(i)));
		I:=trim minors(i,N);
		print("    Taking radical...");
		ranklt#i=radical I;
	);
	for i from mindim+1 when i<=n do (
		ranklt#i=ideal (0_(ring(N)));
	);
	return ranklt;
);

stratifyByRank(Module) := (m) -> (
	assert(isModuleOfVectorFields(m));
	return stratifyByRank(gens m);
);

mydoc=concatenate(mydoc,///
Node
	Key
		getDim
		(getDim,Ideal)
	Headline
		Compute the dimension of the variety defined by a prime ideal
	Usage
		d=getDim(I)
	Inputs
		I:Ideal
			a prime ideal
	Outputs
		d:ZZ
			the dimension of the affine variety defined by a prime ideal
	Description
		Text
			Compute the dimension of an affine variety defined by a prime ideal.
		Example
			R=QQ[a,b,c];
			getDim(ideal (a,b))
	SeeAlso
		VectorFields
///);

getDim = method();
getDim(Ideal) := (I) -> (
	-- I is a prime ideal defining an irreducible variety. 
	assert(isPrime(I));
	return dim(ring(I)/(I));
);

mydoc=concatenate(mydoc,///
Node
	Key
		isHolonomic
		(isHolonomic,Ideal)
		(isHolonomic,RingElement)
	Headline
		Test whether an algebraic set is holonomic
	Usage
		b=isHolonomic(I)
		b=isHolonomic(H)
	Inputs
		I:Ideal
			an ideal defining an algebraic set
		H:RingElement
			a nonzero function defining a hypersurface
	Outputs
		b:Boolean
			whether the hypersurface is holonomic
	Description
		Text
			An analytic germ is called holonomic if the stratification-by-rank of the logarithmic
			vector fields agrees with the canonical Whitney stratification of the germ.  This is
			checked by computing the stratification-by-rank of derlogV(I), and checking the dimensions
			of the irreducible components of each stratum.  The test we use is described in
			'Solvable Groups, free divisors, and nonisolated matrix singularities II' by Damon and Pike.
		Example
			R=QQ[a,b,c];
		Text
			This is not holonomic, as D has rank 0 on a=b=0
		Example
			f=a*b*(a-b)*(a-c*b);
			D=derlogV(ideal (f))
			isHolonomic(f)
		Text
			Whereas this is Holonomic
		Example
			isHolonomic(a*c-b^2)
	SeeAlso
		isHHolonomic
		derlogV
		stratifyByRank
		VectorFields
///);

isHolonomic = method();
isHolonomic(Ideal) := (I) -> (
	-- I is an Ideal defining an algebraic set.
	DV:=derlogV(I);
	sV:=stratifyByRank(DV);
	-- dimension of space.
	n:=numColumns vars(ring(I));

	assert(numColumns(DV)>=n);
	-- A special case (ambient space).  Now assume V(I) has dimension <n.
	if (I==0) then return true;
	-- We'll always have sV#n===radical I, since the vfs should have rank n off V(I).
	-- But check anyway.
	-- Does DV have rank <n exactly on V(I)?
	assert(sV#n===radical I);
	-- Let D_k be the locus of rank <=k, so it is defined by sV#(k+1)
	-- Check that the dimension of each irreducible component of D_k has dimension <=k, for 0<=k<n.
	-- Translating indices:
	-- Check that the dimension of each irreducible component of V(sV#j) has dimension <j, for 1<=j<=n.
	-- We've already checked j=n, since I<>(0)
	for j from 1 when j<=(n-1) do (
		-- Make sure that all components of sV#j have dimension <j.
		l:=primaryDecomposition (sV#j);
		ld:=apply(l,getDim);
		m:=max(ld);
		if (m>=j) then (
			p:=position(ld, i-> (i==m));
			print(concatenate("Stratum ",toString(l#p), " has dimension ",toString(m)," but should be of dimension less than ",toString(j)));
			return false;
		);
	);
	return true;
);

isHolonomic(RingElement) := (H) -> (
	-- H is a ringElement defining a hypersurface.
	return isHolonomic(ideal (H));
);

mydoc=concatenate(mydoc,///
Node
	Key
		isHHolonomic
		(isHHolonomic,RingElement)
	Headline
		Test whether a hypersurface is H-holonomic
	Usage
		b=isHHolonomic(H)
	Inputs
		H:RingElement
			a nonzero function defining a hypersurface
	Outputs
		b:Boolean
			whether the hypersurface is H-holonomic
	Description
		Text
			An analytic germ is called holonomic if the stratification-by-rank of the logarithmic
			vector fields agrees with the canonical Whitney stratification of the germ.
			A hypersurface defined by H is called H-holonomic if also the stratification-by-rank of
			the vector fields annihilating H agrees with the canonical Whitney stratification, at
			least on the hypersurface.  The test we use is described in
			'Solvable Groups, free divisors, and nonisolated matrix singularities II' by Damon and Pike.
		Example
			R=QQ[a,b,c];
		Text
			This is not even holonomic, as D has rank 0 on a=b=0
		Example
			f=a*b*(a-b)*(a-c*b);
			D=derlogV(ideal (f))
			isHHolonomic(f)
		Text
			Whereas this one is H-Holonomic
		Example
			isHHolonomic(a*c-b^2)
	SeeAlso
		derlogV
		derlogH
		stratifyByRank
		VectorFields
///);

isHHolonomic = method();
isHHolonomic(RingElement) := (H) -> (
	-- H is a ringElement defining a hypersurface; we'll check if it's H-holonomic.
	-- This is a stupid special case, where derlogV()=derlogH()=everything.
	if (H==0) then return true;
	-- Now stratify-by-rank everything
	DH:=derlogH(ideal (H));
	sH:=stratifyByRank(DH);
	DV:=derlogV(ideal (H));
	sV:=stratifyByRank(DV);
	-- dimension of space.
	n:=numColumns vars(ring(H));

	assert(numColumns(DV)>=n);
	-- Since H*d/dxi is in DV, sV#n===radical ideal(H)
	-- Make sure DV is linearly dependent exactly on H=0.
	assert(sV#n===radical ideal (H));
	-- However, DH may have fewer than n vector fields, so we can't take
	--   n x n minors.  Instead, stop at (n-1). 
	for i from 1 when i<=(n-1) do (
		-- Check if sH#i and sV#i are the same.
		if not(sH#i==sV#i) then (
			print(concatenate("DerlogH and DerlogV differ at level ",toString(i)));
			return false;
		);
		-- Now make sure that all components of sV#i have dimension <i.
		l:=primaryDecomposition (sV#i);
		ld:=apply(l,getDim);
		m:=max(ld);
		if (m>=i) then (
			p:=position(ld, i-> (i==m));
			print(concatenate("Stratum ",toString(l#p), " has dimension ",toString(m)," but should be of dimension less than ",toString(i)));
			return false;
		);
	);
	return true;
);

beginDocumentation();
--print(mydoc);
multidoc(mydoc);

--TEST ///
--    assert ( firstFunction 2 == "D'oh!" )
--///
